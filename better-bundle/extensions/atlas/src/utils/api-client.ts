const UNIFIED_ANALYTICS_BASE_URL = process.env.BACKEND_URL;

/**
 * Get unified browser session ID (shared across ALL extensions)
 * This should match the ID generated by Phoenix/Apollo
 */
const getBrowserSessionId = async (sessionStorage: any): Promise<string> => {
  let sessionId = await sessionStorage.getItem("unified_browser_session_id");
  if (!sessionId) {
    sessionId =
      "unified_" + Date.now() + "_" + Math.random().toString(36).substr(2, 9);
    await sessionStorage.setItem("unified_browser_session_id", sessionId);
  }
  return sessionId;
};

/**
 * Get or store Shopify client ID in sessionStorage
 * This allows other extensions to access it
 */
const getOrStoreClientId = async (
  sessionStorage: any,
  clientId: string | null,
): Promise<string | null> => {
  // Try to get existing client_id from sessionStorage
  let storedClientId = await sessionStorage.getItem("unified_client_id");

  // If we have a new client_id from event and it's different, update it
  if (clientId && clientId !== storedClientId) {
    await sessionStorage.setItem("unified_client_id", clientId);
    console.log(
      "üì± Atlas: Stored client_id in sessionStorage:",
      clientId.substring(0, 16) + "...",
    );
    return clientId;
  }

  // Return stored one if available
  return storedClientId || clientId;
};

let sessionCreationPromise: Promise<string> | null = null;

/**
 * Get or create a session for Atlas tracking
 */
export const getOrCreateSession = async (
  shopDomain: string,
  userAgent: string,
  customerId: string | null,
  pageUrl: string,
  referrer: string,
  sessionStorage: any,
  clientId: string,
): Promise<string> => {
  const storedClientId = await getOrStoreClientId(sessionStorage, clientId);

  // ‚úÖ STEP 2: Check if we have a valid cached session
  const storedSessionId = await sessionStorage.getItem("unified_session_id");
  const storedExpiresAt = await sessionStorage.getItem(
    "unified_session_expires_at",
  );

  if (
    storedSessionId &&
    storedExpiresAt &&
    Date.now() < parseInt(storedExpiresAt)
  ) {
    console.log("‚ö° Atlas: Reusing cached session:", storedSessionId);

    // ‚úÖ IMPORTANT: If we have a NEW client_id, update backend in background
    if (clientId && clientId !== storedClientId) {
      console.log("üîÑ Atlas: Updating client_id in background");
      updateClientIdInBackground(storedSessionId, clientId, shopDomain).catch(
        (err) => {
          console.warn("‚ö†Ô∏è Failed to update client_id in background:", err);
        },
      );
    }

    return storedSessionId;
  }

  // ‚úÖ STEP 3: Check if another Atlas call is already creating a session (race condition prevention)
  if (sessionCreationPromise) {
    console.log("üîí Atlas: Session creation already in progress, waiting...");
    return await sessionCreationPromise;
  }

  sessionCreationPromise = (async () => {
    try {
      const url = `${UNIFIED_ANALYTICS_BASE_URL}/api/atlas/get-or-create-session`;
      const browserSessionId = await getBrowserSessionId(sessionStorage);

      const payload = {
        shop_domain: shopDomain,
        customer_id: customerId,
        browser_session_id: browserSessionId,
        client_id: storedClientId || clientId, // Use latest available
        user_agent: userAgent,
        ip_address: null, // Will be detected server-side
        referrer: referrer,
        page_url: pageUrl,
      };

      const response = await fetch(url, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify(payload),
        keepalive: true,
      });

      if (!response.ok) {
        throw new Error(`Session creation failed: ${response.status}`);
      }

      const result = await response.json();

      if (result.success && result.data && result.data.session_id) {
        const sessionId = result.data.session_id;
        const expiresAt = Date.now() + 30 * 60 * 1000; // 30 minutes from now

        // Store session data in sessionStorage for persistence (unified across all extensions)
        await sessionStorage.setItem("unified_session_id", sessionId);
        await sessionStorage.setItem(
          "unified_session_expires_at",
          expiresAt.toString(),
        );

        // ‚úÖ NEW: Store backend's client_id if returned
        if (result.data.client_id) {
          await sessionStorage.setItem(
            "unified_client_id",
            result.data.client_id,
          );
        }

        return sessionId;
      } else {
        throw new Error(result.message || "Failed to create session");
      }
    } catch (error) {
      throw error;
    } finally {
      sessionCreationPromise = null;
    }
  })();
  return await sessionCreationPromise;
};

/**
 * Track interaction using unified analytics
 */
export const trackInteraction = async (
  event: any,
  shopDomain: string,
  userAgent: string,
  customerId: string | null,
  interactionType: string,
  pageUrl: string,
  referrer: string,
  sessionStorage: any,
  sendBeacon: any,
): Promise<void> => {
  try {
    const clientId = event?.clientId || null;

    const sessionId = await getOrCreateSession(
      shopDomain,
      userAgent,
      customerId,
      pageUrl,
      referrer,
      sessionStorage,
      clientId,
    );

    const interactionData = {
      session_id: sessionId,
      shop_domain: shopDomain,
      customer_id: customerId,
      interaction_type: interactionType,
      metadata: {
        ...event,
      },
    };

    // Send to unified analytics endpoint
    const url = `${UNIFIED_ANALYTICS_BASE_URL}/api/atlas/track-interaction`;

    const response = await fetch(url, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify(interactionData),
      keepalive: true,
    });

    if (!response.ok) {
      throw new Error(`Interaction tracking failed: ${response.status}`);
    }

    const result = await response.json();

    // Handle session recovery if it occurred
    if (result.session_recovery) {
      console.log("üîÑ Atlas: Session recovered:", result.session_recovery);
      // Update stored session ID with the new one (unified with other extensions)
      await sessionStorage.setItem(
        "unified_session_id",
        result.session_recovery.new_session_id,
      );
    }
  } catch (error) {
    throw error;
  }
};

const updateClientIdInBackground = async (
  sessionId: string,
  clientId: string,
  shopDomain: string,
): Promise<void> => {
  try {
    const url = `${UNIFIED_ANALYTICS_BASE_URL}/api/session/update-client-id`;

    await fetch(url, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        session_id: sessionId,
        client_id: clientId,
        shop_domain: shopDomain,
      }),
      keepalive: true,
    });

    console.log("‚úÖ Atlas: client_id updated in background");
  } catch (error) {
    console.warn("‚ö†Ô∏è Atlas: Background client_id update failed:", error);
    // Don't throw - this is non-critical
  }
};
